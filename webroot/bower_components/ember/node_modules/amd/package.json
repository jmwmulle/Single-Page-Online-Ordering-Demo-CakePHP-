{
  "name": "amd",
  "description": "Async Module Definition - module loader/bunder for node + browser",
  "version": "0.0.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/amd.git"
  },
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "bit.ly/dominictarr"
  },
  "main": "amd.js",
  "directories": {
    "lib": "."
  },
  "bin": {
    "amd": "go.js"
  },
  "scripts": {
    "test": "meta-test test/*.js"
  },
  "engines": {
    "node": "*"
  },
  "files": [],
  "homepage": "https://github.com/dominictarr/amd",
  "readme": "#A lightweight module loader for node and the browser.\n\nThe goal of AMD is to create the simplest possible \nmodule loader that is compatible with both node and the browser. it is a partial implementation of [CommonJS/Modules/SimpleAsynchronous] (http://wiki.commonjs.org/wiki/Modules/SimpleAsynchronous)\n\nAMD forces you to declare all your dependencies up front, \nand not require anything new after that point. \n\nThis makes module loading easy.\n\n##AMD modules:\n\n  * work in browser and node\n  * can be loaded with require() from normal node modules.\n  * does not add any overhead to the modules - unlike other node-browser-module systems!\n\nIt is necessary to define your modules a new way:\n\n###the old way:\n\n    //ab.js\n    var a = require('./a')\n      , b = require('./b')\n      \n    exports.ab = function (x){return a(b(x))}\n\n###the NEW way:\n\n    //ab.js - amd style\n    require('amd') // (loads monkeypatch which makes amd work in node)\n\n    module.define(['./a', './b'], function AB (a,b){\n    \n      return {ab: function (x){return a(b(x))} } //exports is returned.\n    })\n\n`module.define` takes two arguments an array of dependencies and a initializer function. \nthe dependencies are loaded and passed to the initializer in the same order that they are in the array. \nThe return value of the initializer is the module's exports.\n\n####then do `$ amd ab.js > ab-browser.js`:\n\nAMD will load the modules, get their dependencies, topologically sort them, \nstringify them, and plug dependencies into the correct places, with very little overhead!\n\nthen it will return a script that you can simply include on your page:\n\n    (function (M){\n    M[1] =\n      (function A(){\n        return function (x){'!' + x + '!'}\n      })();\n    \n    M[2] =\n      (function B(){\n        return function (x){'?' + x + '?'}\n      })();\n    \n    return  (function AB(a,b){\n        return function (x){return a(b(x))} //exports is returned.\n      })(M[1],M[2]);\n    \n    })({});\n\n##limitations\n\nAMD does not support:\n\n  * circular dependencies.\n  * dynamic dependencies.\n  * `__filename`, `__dirname`, or `module` variables (in the browser)\n  * no way to catch errors which may occur in the initializer functions.\n \nIf you think these features should be supported please \n[email me] (mailto:dominic.tarr@gmail.com) with your use-case.\n\nCurrently these features are ignored to keep this module simple, \nor because they aren't appropriate on browser side modules.\n\n##FORTHCOMING FEATURES: (things I am thinking about, at least)\n\n  * get semi-dynamic dependencies by specifying passing dependencies to amd/bundle.\n  * way to catch errors or defer loading, so that it is possible to write a test framework.\n",
  "readmeFilename": "readme.markdown",
  "bugs": {
    "url": "https://github.com/dominictarr/amd/issues"
  },
  "_id": "amd@0.0.0",
  "dist": {
    "shasum": "2ddfcc09787d18eb894de8bc50404ffdc24582c1"
  },
  "_from": "amd@",
  "_resolved": "https://registry.npmjs.org/amd/-/amd-0.0.0.tgz"
}
